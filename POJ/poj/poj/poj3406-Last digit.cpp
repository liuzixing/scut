//其中最关键的一点在这一步// 欷堡葡乱昏欷等しくなるansをつける
//	for(ans=1;1;++ans)
//	{
//		if( (tm*ans)%10==tn%10 )break;
//	}
//

//注意：下面式子中使用的n,m实际上是已经提取出2，5因子后的结果，为了书写方便这里仍使用原值表示。
//
//
//	对于C(n,m)很明显的结论是 n!/(m!*(n-m)!)必然是个整数，n!中的因子2，5的个数必然大于m!*(n-m)!的
//
//	以 C(10,3)为例=(10*9*8)/(3*2*1)，把2，5提取之后变成了，(1*9*1)/(3*1*1)，我们的目标就是要计算这个算式最后结果的last digit，然后再结合2,5的因子个数，确定最终的last digit.
//
//	对于这个需求，上面的代码实际上做了这样一直判断，因为分子必然是下面分母的整数倍，对分子进行了扩大处理扩大的同时保证各个扩大后的数的最后一位与原来相同,即(m-i)*ans%10==(n-i)%10
//
//	(m*ans1)*(m-1*ans2)*(m-2*ans3)....../m*m-1*m-2......
//
//	可以看到实际上是用上面这个列代替了n*n-1*n-2.../m*m-1*m-2......但是我们需要证明这个替换是不会改变最终结果的，而这样替换的原因是m*ans1可以直接就是m的整数倍，可以直接约分，最终实际变成ans1*ans2*ans3....%10的 last digit。
//
//	实际上这个替换的正确性基于如下两个保证：
//
//	首先：替换的时候要保证[(m-i)*ans1]% 10 = (n-i) %10,这样实际上可以保证(m*ans1)*(m-1*ans2)*(m-2*ans3)...与n*n-1*n-2...结果的last digit是相同的
//
//	其次：当分子，分母的last digit最后一位确定之后，它们的除法结果的last digit也是确定了
//
//	这点可以通过，枚举证明，因为最后一位可能只有 1,3,7,9,如下：
//
//	当1为分子,则在可以整除的前提下，如下方程是只具有唯一解的
//
//	(1*x)%10=1 (3*x)%10=1 (7*x)%10=1 (9*x)%10=1 且 x <-{1,2,7,9}
//
//
//当3为分子,则在可以整除的前提下，如下方程是只具有唯一解的
//
//	(1*x)%10=3 (3*x)%10=3 (7*x)%10=3 (9*x)%10=3  且 x <-{1,2,7,9}
//
//当7,9为分子是也是唯一的，这就说明了如果分子最后一位为x,分母最后一位为y，因为已经保证整除，这时我们就能确定最后的除法结果的最后一位。
//
//	所以我们只要在对分子扩大时，只要保证最终的结果与未扩大时的last digit相同，同时保证能继续整除分母就可以了
//

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n, m, n2, n5, m2, m5; 
int main() 
{    
	int i, j;    
	scanf("%d%d", &n, &m);    
	int tn, tm, ans = 1;    
	n2 = n5 = m2 = m5 = 0;    
	for (i = 0; i < m; i++) 
	{       
		tn = ans * (n - i);        
		tm = m - i;       
		while (tn % 2 == 0) 
		{           
			n2++;            
			tn /= 2;        
		}        
		while (tn % 5 == 0) 
		{            
			n5++;            
			tn /= 5;        
		}        
		while (tm % 2 == 0) 
		{            
			m2++;           
			tm /= 2;     
		}       
		while (tm % 5 == 0) 
		{            
			m5++;            
			tm /= 5;        
		}        
		for (ans = 1;; ans++)          
			if ((ans * tm ) % 10 == (tn % 10)) break;    
	}    
	n2 = n2 - m2;    
	n5 = n5 - m5;    
	if (n5 > n2) 
	{       
		printf("5\n"); 
		return 0;   
	}    
	n2 = n2 - n5;    
	while (n2--)ans = (ans * 2) % 10;    
	printf("%d\n", ans);    
	return 0;
}